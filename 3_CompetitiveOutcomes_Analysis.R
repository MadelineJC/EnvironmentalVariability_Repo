#### DOC STRING ===============================================================
# This script looks for patterns in which parasite outlasts which under a 
# given set of circumstances. More specifically, this script wrangles time 
# series outputs to determine which parasite populations falls to an abundance 
# <1 first, and at which time step co-occurrence ends. 

# To run this script, you'll need to download twelve files from the link specified
# in this repository's README, into 
# "EnvironmentalVariability_Repo/Data/EnvStoch-DemEnvStoch_PV_Outputs". 
# The files are named as follows: E_LT_Semi.rds, E_LT_PiAd.rds, E_LT_PjAd.rds, 
# E_HT_Semi.rds, E_HT_PiAd.rds, E_HT_PjAd.rds, DE_LT_Semi.rds, DE_LT_PiAd.rds, 
# DE_LT_PjAd.rds, DE_HT_Semi.rds, DE_HT_PiAd.rds, and DE_HT_PjAd.rds. Outputs
# will be stored in "EnvironmentalVariability_Repo/Generated_Outputs".

# To see the outputs generated by this script without running it, go to 
# "EnvironmentalVariability_Repo/Outputs/CompetitiveOutcomes_Outputs".
#### END DOC STRING============================================================

#### Required packages ####
install.packages("dplyr"); library(dplyr)

#### E_LT_Semi ####
E_LT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_Semi.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_LT_Semi)){
  for (j in 1:length(E_LT_Semi[[i]])){
    for (k in 1:length(E_LT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_LT_Semi)){
  for (j in 1:length(E_LT_Semi[[i]])){
    for (k in 1:length(E_LT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, Semi))
Permutes <- c()
for (i in 1:length(E_LT_Semi[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_Semi_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_Semi_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_Semi_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_Semi_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_Semi_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_Semi_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_Semi_Fr10Mag10_Sums))
colnames(LT_Semi_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_Semi_Fr10Mag10_Sums, "Generated_Outputs/E_LT_Semi_Fr10Mag10_Sums.rds")

#### E_LT_PiAd ####
E_LT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_PiAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_LT_PiAd)){
  for (j in 1:length(E_LT_PiAd[[i]])){
    for (k in 1:length(E_LT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_LT_PiAd)){
  for (j in 1:length(E_LT_PiAd[[i]])){
    for (k in 1:length(E_LT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, PiAd))
Permutes <- c()
for (i in 1:length(E_LT_PiAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_PiAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_PiAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_PiAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_PiAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_PiAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_PiAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_PiAd_Fr10Mag10_Sums))
colnames(LT_PiAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_PiAd_Fr10Mag10_Sums, "Generated_Outputs/E_LT_PiAd_Fr10Mag10_Sums.rds")

#### E_LT_PjAd ####
E_LT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_PjAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_LT_PjAd)){
  for (j in 1:length(E_LT_PjAd[[i]])){
    for (k in 1:length(E_LT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_LT_PjAd)){
  for (j in 1:length(E_LT_PjAd[[i]])){
    for (k in 1:length(E_LT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, PjAd))
Permutes <- c()
for (i in 1:length(E_LT_PjAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_PjAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_PjAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_PjAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_PjAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_PjAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_PjAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_PjAd_Fr10Mag10_Sums))
colnames(LT_PjAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_PjAd_Fr10Mag10_Sums, "Generated_Outputs/E_LT_PjAd_Fr10Mag10_Sums.rds")

#### E_HT_Semi ####
E_HT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_Semi.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_HT_Semi)){
  for (j in 1:length(E_HT_Semi[[i]])){
    for (k in 1:length(E_HT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_HT_Semi)){
  for (j in 1:length(E_HT_Semi[[i]])){
    for (k in 1:length(E_HT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, Semi))
Permutes <- c()
for (i in 1:length(E_HT_Semi[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_Semi_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_Semi_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_Semi_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_Semi_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_Semi_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_Semi_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_Semi_Fr10Mag10_Sums))
colnames(HT_Semi_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_Semi_Fr10Mag10_Sums, "Generated_Outputs/E_HT_Semi_Fr10Mag10_Sums.rds")

#### E_HT_PiAd ####
E_HT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_PiAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_HT_PiAd)){
  for (j in 1:length(E_HT_PiAd[[i]])){
    for (k in 1:length(E_HT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_HT_PiAd)){
  for (j in 1:length(E_HT_PiAd[[i]])){
    for (k in 1:length(E_HT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, PiAd))
Permutes <- c()
for (i in 1:length(E_HT_PiAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_PiAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_PiAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_PiAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_PiAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_PiAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_PiAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_PiAd_Fr10Mag10_Sums))
colnames(HT_PiAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_PiAd_Fr10Mag10_Sums, "Generated_Outputs/E_HT_PiAd_Fr10Mag10_Sums.rds")

#### E_HT_PjAd ####
E_HT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_PjAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(E_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(E_HT_PjAd)){
  for (j in 1:length(E_HT_PjAd[[i]])){
    for (k in 1:length(E_HT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(E_HT_PjAd)){
  for (j in 1:length(E_HT_PjAd[[i]])){
    for (k in 1:length(E_HT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, PjAd))
Permutes <- c()
for (i in 1:length(E_HT_PjAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_PjAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_PjAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_PjAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_PjAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_PjAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_PjAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_PjAd_Fr10Mag10_Sums))
colnames(HT_PjAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_PjAd_Fr10Mag10_Sums, "Generated_Outputs/E_HT_PjAd_Fr10Mag10_Sums.rds")

#### DE_LT_Semi ####
DE_LT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_Semi.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_LT_Semi)){
  for (j in 1:length(DE_LT_Semi[[i]])){
    for (k in 1:length(DE_LT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_LT_Semi)){
  for (j in 1:length(DE_LT_Semi[[i]])){
    for (k in 1:length(DE_LT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, Semi))
Permutes <- c()
for (i in 1:length(DE_LT_Semi[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_Semi_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_Semi_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_Semi_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_Semi_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_Semi_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_Semi_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_Semi_Fr10Mag10_Sums))
colnames(LT_Semi_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_Semi_Fr10Mag10_Sums, "Generated_Outputs/DE_LT_Semi_Fr10Mag10_Sums.rds")

#### DE_LT_PiAd ####
DE_LT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_PiAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_LT_PiAd)){
  for (j in 1:length(DE_LT_PiAd[[i]])){
    for (k in 1:length(DE_LT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_LT_PiAd)){
  for (j in 1:length(DE_LT_PiAd[[i]])){
    for (k in 1:length(DE_LT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, PiAd))
Permutes <- c()
for (i in 1:length(DE_LT_PiAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_PiAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_PiAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_PiAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_PiAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_PiAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_PiAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_PiAd_Fr10Mag10_Sums))
colnames(LT_PiAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_PiAd_Fr10Mag10_Sums, "Generated_Outputs/DE_LT_PiAd_Fr10Mag10_Sums.rds")

#### DE_LT_PjAd ####
DE_LT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_PjAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 30, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_LT_PjAd)){
  for (j in 1:length(DE_LT_PjAd[[i]])){
    for (k in 1:length(DE_LT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_LT_PjAd)){
  for (j in 1:length(DE_LT_PjAd[[i]])){
    for (k in 1:length(DE_LT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (LT, PjAd))
Permutes <- c()
for (i in 1:length(DE_LT_PjAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
LT_PjAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  LT_PjAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  LT_PjAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  LT_PjAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(LT_PjAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
LT_PjAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, LT_PjAd_Fr10Mag10_Sums))
colnames(LT_PjAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(LT_PjAd_Fr10Mag10_Sums, "Generated_Outputs/DE_LT_PjAd_Fr10Mag10_Sums.rds")

#### DE_HT_Semi ####
DE_HT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_Semi.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_HT_Semi)){
  for (j in 1:length(DE_HT_Semi[[i]])){
    for (k in 1:length(DE_HT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_HT_Semi)){
  for (j in 1:length(DE_HT_Semi[[i]])){
    for (k in 1:length(DE_HT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, Semi))
Permutes <- c()
for (i in 1:length(DE_HT_Semi[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_Semi_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_Semi_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_Semi_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_Semi_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_Semi_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_Semi_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_Semi_Fr10Mag10_Sums))
colnames(HT_Semi_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_Semi_Fr10Mag10_Sums, "Generated_Outputs/DE_HT_Semi_Fr10Mag10_Sums.rds")

#### DE_HT_PiAd ####
DE_HT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_PiAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_HT_PiAd)){
  for (j in 1:length(DE_HT_PiAd[[i]])){
    for (k in 1:length(DE_HT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_HT_PiAd)){
  for (j in 1:length(DE_HT_PiAd[[i]])){
    for (k in 1:length(DE_HT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, PiAd))
Permutes <- c()
for (i in 1:length(DE_HT_PiAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_PiAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_PiAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_PiAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_PiAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_PiAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_PiAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_PiAd_Fr10Mag10_Sums))
colnames(HT_PiAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_PiAd_Fr10Mag10_Sums, "Generated_Outputs/DE_HT_PiAd_Fr10Mag10_Sums.rds")

#### DE_HT_PjAd ####
DE_HT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_PjAd.rds")

#### ... Required objects and re-arranging ####
# Get info + dimensions type of stuff from the .rds
col_num <- ncol(DE_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)
Freq <- c(1, 2, 5, seq(10, 100,10))
IntroPt <- seq(0, 49, 1)
SD <- seq(2, 40, 2)
# Re-arrange list into list of dfs and name them by permutation 
TimeSeries <- list()
l = 1
for (i in 1:length(DE_HT_PjAd)){
  for (j in 1:length(DE_HT_PjAd[[i]])){
    for (k in 1:length(DE_HT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
Names <- c()
for (i in 1:length(DE_HT_PjAd)){
  for (j in 1:length(DE_HT_PjAd[[i]])){
    for (k in 1:length(DE_HT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", Freq[i], "_In", IntroPt[j], "_Mag", SD[k])))
    }
  }
}
names(TimeSeries) <- Names
# Get positions of the dfs we're interested in (intermediate mag. and freq. of disturbance, across all intro times (HT, PjAd))
Permutes <- c()
for (i in 1:length(DE_HT_PjAd[[i]])){
  Permutes[i] <- which(Names == paste("Fr10_In", i-1, "_Mag10", sep = ""))
}
# Organise those data by state variable
Pis <- list(); Pjs <- list()
for (i in 1:length(Permutes)){
  Pis[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pi]
  Pjs[[i]] <- TimeSeries[[Permutes[i]]][Iter_Pj]
}
Names <- c()
for (i in 1:length(Permutes)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; names(Pis) <- Names; names(Pjs) <- Names

#### ... Finding 0s ####
# Find the 0 abundances, and the position of their first appearance 
Pi_0s <- data.frame(); Pj_0s <- data.frame()
k <- 1
for (i in 1:length(Pis)){
  for (j in 1:ncol(Pis[[i]])){
    temp_i <- c(which(Pis[[i]][ ,j] %in% 0)); F0_Pi_Pos <- temp_i[1] # Pi always in system at beginning
    temp_j <- c(which(Pjs[[i]][ ,j] %in% 0)); F0_Pj_Pos <- temp_j[k] # Pj introduced 10 steps later at every new intro point
    Pi_0s[j, i] <- F0_Pi_Pos; Pj_0s[j, i] <- F0_Pj_Pos # Where j is simulation number and i is intro time
  }
  if (k == 1){
    k <- 12
  } else {
    k <- k + 10
  }
}
Names <- c()
for (i in 1:ncol(Pi_0s)){
  Names[i] <- paste("Fr10_In", i-1, "_Mag10", sep = "")
}; colnames(Pi_0s) <- Names; colnames(Pj_0s) <- Names

# Re-arranging data to compare first 0s (could have written this more efficiently, but we're here now!)
First0_List <- list()
for (i in 1:ncol(Pi_0s)){
  First0_List[[i]] <- data.frame(cbind(Pi_0s[ ,i], Pj_0s[ ,i]))
  colnames(First0_List[[i]]) <- c("Pi_First0", "Pj_First0")
}; names(First0_List) <- Names

#### ... Winners and losers ####
# Finding winners and losers
Winner_DF <- data.frame()
for (i in 1:length(First0_List)){
  for (j in 1:nrow(First0_List[[i]])){
    if (First0_List[[i]][j, 1] > First0_List[[i]][j, 2]){x <- "Pi_Wins"}
    if (First0_List[[i]][j, 1] < First0_List[[i]][j, 2]){x <- "Pj_Wins"}
    if (First0_List[[i]][j, 1] == First0_List[[i]][j, 2]){x <- "Tie"}
    Winner_DF[j ,i] <- x
  }
}; colnames(Winner_DF) <- Names

#### ... Summarizing and saving ####
HT_PjAd_Fr10Mag10_Sums <- data.frame(matrix(ncol = 3))
for (i in 1:ncol(Winner_DF)){
  HT_PjAd_Fr10Mag10_Sums[i, 1] <- sum(Winner_DF[ ,i] == "Pi_Wins")
  HT_PjAd_Fr10Mag10_Sums[i, 2] <- sum(Winner_DF[ ,i] == "Pj_Wins")
  HT_PjAd_Fr10Mag10_Sums[i, 3] <- sum(Winner_DF[ ,i] == "Tie")
}
Intros <- c(); x <- seq(0, 49, 1)
for (i in 1:nrow(HT_PjAd_Fr10Mag10_Sums)){
  Intros[i] <- x[i]
}
HT_PjAd_Fr10Mag10_Sums <- data.frame(cbind(Intros, HT_PjAd_Fr10Mag10_Sums))
colnames(HT_PjAd_Fr10Mag10_Sums) <- c("Intro", "Pi_Wins", "Pj_Wins", "Ties")

saveRDS(HT_PjAd_Fr10Mag10_Sums, "Generated_Outputs/DE_HT_PjAd_Fr10Mag10_Sums.rds")

#### FULL COUNTS ####
#### E_LT_Semi ####
E_LT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_Semi.rds")
col_num <- ncol(E_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_LT_Semi)){
  for (j in 1:length(E_LT_Semi[[i]])){
    for (k in 1:length(E_LT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(E_LT_Semi)){
  for (j in 1:length(E_LT_Semi[[i]])){
    for (k in 1:length(E_LT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_LT_Semi_Counts <- list(); E_LT_Semi_Counts[[1]] <- PiWins; E_LT_Semi_Counts[[2]] <- PjWins; E_LT_Semi_Counts[[3]] <- Ties

saveRDS(E_LT_Semi_Counts, "Generated_Outputs/E_LT_Semi_Counts.rds")

#### E_LT_PiAd ####
E_LT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_PiAd.rds")
col_num <- ncol(E_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_LT_PiAd)){
  for (j in 1:length(E_LT_PiAd[[i]])){
    for (k in 1:length(E_LT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(E_LT_PiAd)){
  for (j in 1:length(E_LT_PiAd[[i]])){
    for (k in 1:length(E_LT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_LT_PiAd_Counts <- list(); E_LT_PiAd_Counts[[1]] <- PiWins; E_LT_PiAd_Counts[[2]] <- PjWins; E_LT_PiAd_Counts[[3]] <- Ties

saveRDS(E_LT_PiAd_Counts, "Generated_Outputs/E_LT_PiAd_Counts.rds")

#### E_LT_PjAd ####
E_LT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_LT_PjAd.rds")
col_num <- ncol(E_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_LT_PjAd)){
  for (j in 1:length(E_LT_PjAd[[i]])){
    for (k in 1:length(E_LT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- E_LT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(E_LT_PjAd)){
  for (j in 1:length(E_LT_PjAd[[i]])){
    for (k in 1:length(E_LT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_LT_PjAd_Counts <- list(); E_LT_PjAd_Counts[[1]] <- PiWins; E_LT_PjAd_Counts[[2]] <- PjWins; E_LT_PjAd_Counts[[3]] <- Ties

saveRDS(E_LT_PjAd_Counts, "Generated_Outputs/E_LT_PjAd_Counts.rds")

#### E_HT_Semi ####
E_HT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_Semi.rds")
col_num <- ncol(E_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_HT_Semi)){
  for (j in 1:length(E_HT_Semi[[i]])){
    for (k in 1:length(E_HT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(E_HT_Semi)){
  for (j in 1:length(E_HT_Semi[[i]])){
    for (k in 1:length(E_HT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_HT_Semi_Counts <- list(); E_HT_Semi_Counts[[1]] <- PiWins; E_HT_Semi_Counts[[2]] <- PjWins; E_HT_Semi_Counts[[3]] <- Ties

saveRDS(E_HT_Semi_Counts, "Generated_Outputs/E_HT_Semi_Counts.rds")

#### E_HT_PiAd ####
E_HT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_PiAd.rds")
col_num <- ncol(E_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_HT_PiAd)){
  for (j in 1:length(E_HT_PiAd[[i]])){
    for (k in 1:length(E_HT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(E_HT_PiAd)){
  for (j in 1:length(E_HT_PiAd[[i]])){
    for (k in 1:length(E_HT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_HT_PiAd_Counts <- list(); E_HT_PiAd_Counts[[1]] <- PiWins; E_HT_PiAd_Counts[[2]] <- PjWins; E_HT_PiAd_Counts[[3]] <- Ties

saveRDS(E_HT_PiAd_Counts, "Generated_Outputs/E_HT_PiAd_Counts.rds")

#### E_HT_PjAd ####
E_HT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/E_HT_PjAd.rds")
col_num <- ncol(E_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(E_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(E_HT_PjAd)){
  for (j in 1:length(E_HT_PjAd[[i]])){
    for (k in 1:length(E_HT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- E_HT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(E_HT_PjAd)){
  for (j in 1:length(E_HT_PjAd[[i]])){
    for (k in 1:length(E_HT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
E_HT_PjAd_Counts <- list(); E_HT_PjAd_Counts[[1]] <- PiWins; E_HT_PjAd_Counts[[2]] <- PjWins; E_HT_PjAd_Counts[[3]] <- Ties

saveRDS(E_HT_PjAd_Counts, "Generated_Outputs/E_HT_PjAd_Counts.rds")

#### DE_LT_Semi ####
DE_LT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_Semi.rds")
col_num <- ncol(DE_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_LT_Semi)){
  for (j in 1:length(DE_LT_Semi[[i]])){
    for (k in 1:length(DE_LT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(DE_LT_Semi)){
  for (j in 1:length(DE_LT_Semi[[i]])){
    for (k in 1:length(DE_LT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_LT_Semi_Counts <- list(); DE_LT_Semi_Counts[[1]] <- PiWins; DE_LT_Semi_Counts[[2]] <- PjWins; DE_LT_Semi_Counts[[3]] <- Ties

saveRDS(DE_LT_Semi_Counts, "Generated_Outputs/DE_LT_Semi_Counts.rds")

#### DE_LT_PiAd ####
DE_LT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_PiAd.rds")
col_num <- ncol(DE_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_LT_PiAd)){
  for (j in 1:length(DE_LT_PiAd[[i]])){
    for (k in 1:length(DE_LT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(DE_LT_PiAd)){
  for (j in 1:length(DE_LT_PiAd[[i]])){
    for (k in 1:length(DE_LT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_LT_PiAd_Counts <- list(); DE_LT_PiAd_Counts[[1]] <- PiWins; DE_LT_PiAd_Counts[[2]] <- PjWins; DE_LT_PiAd_Counts[[3]] <- Ties

saveRDS(DE_LT_PiAd_Counts, "Generated_Outputs/DE_LT_PiAd_Counts.rds")

#### DE_LT_PjAd ####
DE_LT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_LT_PjAd.rds")
col_num <- ncol(DE_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_LT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_LT_PjAd)){
  for (j in 1:length(DE_LT_PjAd[[i]])){
    for (k in 1:length(DE_LT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_LT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,30,2)
for (i in 1:length(DE_LT_PjAd)){
  for (j in 1:length(DE_LT_PjAd[[i]])){
    for (k in 1:length(DE_LT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_LT_PjAd_Counts <- list(); DE_LT_PjAd_Counts[[1]] <- PiWins; DE_LT_PjAd_Counts[[2]] <- PjWins; DE_LT_PjAd_Counts[[3]] <- Ties

saveRDS(DE_LT_PjAd_Counts, "Generated_Outputs/DE_LT_PjAd_Counts.rds")

#### DE_HT_Semi ####
DE_HT_Semi <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_Semi.rds")
col_num <- ncol(DE_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_Semi[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_HT_Semi)){
  for (j in 1:length(DE_HT_Semi[[i]])){
    for (k in 1:length(DE_HT_Semi[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_Semi[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(DE_HT_Semi)){
  for (j in 1:length(DE_HT_Semi[[i]])){
    for (k in 1:length(DE_HT_Semi[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_HT_Semi_Counts <- list(); DE_HT_Semi_Counts[[1]] <- PiWins; DE_HT_Semi_Counts[[2]] <- PjWins; DE_HT_Semi_Counts[[3]] <- Ties

saveRDS(DE_HT_Semi_Counts, "Generated_Outputs/DE_HT_Semi_Counts.rds")

#### DE_HT_PiAd ####
DE_HT_PiAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_PiAd.rds")
col_num <- ncol(DE_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_PiAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_HT_PiAd)){
  for (j in 1:length(DE_HT_PiAd[[i]])){
    for (k in 1:length(DE_HT_PiAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_PiAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(DE_HT_PiAd)){
  for (j in 1:length(DE_HT_PiAd[[i]])){
    for (k in 1:length(DE_HT_PiAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_HT_PiAd_Counts <- list(); DE_HT_PiAd_Counts[[1]] <- PiWins; DE_HT_PiAd_Counts[[2]] <- PjWins; DE_HT_PiAd_Counts[[3]] <- Ties

saveRDS(DE_HT_PiAd_Counts, "Generated_Outputs/DE_HT_PiAd_Counts.rds")

#### DE_HT_PjAd ####
DE_HT_PjAd <- readRDS("Data/EnvStoch-DemEnvStoch_PV_Outputs/DE_HT_PjAd.rds")
col_num <- ncol(DE_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 3001
row_num <- nrow(DE_HT_PjAd[["Each_1"]][["Intro_0"]][["SD_2"]]) # 501
Iter_Pi <- seq(2, col_num, 3)
Iter_Pj <- seq(3, col_num, 3)

#### ... Data wrangling ####
# Putting all the timeseries dataframes into a list so they're easier to access
TimeSeries <- list() # Should end up being of length: length(freq)*length(IntroPt)*length(sd)
l = 1
for (i in 1:length(DE_HT_PjAd)){
  for (j in 1:length(DE_HT_PjAd[[i]])){
    for (k in 1:length(DE_HT_PjAd[[i]][[j]])){
      TimeSeries[[l]] <- DE_HT_PjAd[[i]][[j]][[k]]
      l = l + 1
    }
  }
}
# Naming each element according to its permutation 
Names <- c(); freq <- c(1, 2, 5, seq(10,100,10)); IntroPt <- seq(0,49,1); sd <- seq(2,40,2)
for (i in 1:length(DE_HT_PjAd)){
  for (j in 1:length(DE_HT_PjAd[[i]])){
    for (k in 1:length(DE_HT_PjAd[[i]][[j]])){
      Names <- c(Names, as.character(paste0("Fr", freq[i], "_In", IntroPt[j], "_Mag", sd[k])))
    }
  }
}
names(TimeSeries) <- Names

#### ... Quantifying outcomes ####
Permute <- which(Names == "Fr10_In0_Mag10")
Pis <- TimeSeries[[Permute]][Iter_Pi] 
Pjs <- TimeSeries[[Permute]][Iter_Pj]
# Making a vector with the time point of each 0 in each time series, of each simulation  
Pi_0s <- list() # Length 1000 bc 1000 simulations; within each list is a vector of every position in the times series where the abundance is 0
for (i in 1:ncol(Pis)){
  temp <- data.frame(which(Pis[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pi_0s[[i]] <- temp
}
Pj_0s <- list()
for (i in 1:ncol(Pjs)){
  temp <- data.frame(which(Pjs[ , i] %in% 0))
  colnames(temp) <- "0s"
  Pj_0s[[i]] <- temp
}
# Finding the first 0s
First0 <- data.frame(SimNum <- seq(1, 1000, 1)) # Length = 1000 because each element will be the position of the first 0 in 1 of 1000 simulations
for (i in 1:length(SimNum)){
  First0[i, 2] <- Pi_0s[[i]][["0s"]][1]
  First0[i, 3] <- Pj_0s[[i]][["0s"]][1] # Because Pj introduced at same time; change this if you're looking at different intro times
}
colnames(First0) <- c("Sim_Num", "Pi_First0", "Pj_First0")

# Count who wins when
Winner <- data.frame(SimNum=seq(1,1000,1))
for (i in 1:length(SimNum)){
  Winner[i, 2] <- First0$Pi_First0[i] > First0$Pj_First0[i]
  Winner[i, 3] <- First0$Pi_First0[i] < First0$Pj_First0[i]
  Winner[i, 4] <- First0$Pi_First0[i] == First0$Pj_First0[i]
}
colnames(Winner) <- c("Sim_Num", "Pi_Wins", "Pj_Wins", "Tie")
Summary <- c(sum(Winner$Pi_Wins, na.rm = TRUE), sum(Winner$Pj_Wins, na.rm = TRUE), sum(Winner$Tie, na.rm = TRUE))

#### ... Wrangling for plotting ####
PiWins <- which(Winner[1:1000, 2] %in% TRUE) # Pi wins
PjWins <- which(Winner[1:1000, 3] %in% TRUE) # Pj wins
Ties <- which(Winner[1:1000, 4] %in% TRUE) # Tie
DE_HT_PjAd_Counts <- list(); DE_HT_PjAd_Counts[[1]] <- PiWins; DE_HT_PjAd_Counts[[2]] <- PjWins; DE_HT_PjAd_Counts[[3]] <- Ties

saveRDS(DE_HT_PjAd_Counts, "Generated_Outputs/DE_HT_PjAd_Counts.rds")
